---
title: mips非对齐指令与大小端
date: 2019-12-21 02:51:12
tags:
description: 在给我们的cpu添加非对齐指令时，最后的总结出来的大小端的区别。
---
# 非对齐指令总结

## 1 大端与小端

- 大端:数据的高位位于内存的低地址，数据的地位位于内存的高地址。
- 小端:与大端相反。

事实上大端更符合人的思维，因为在写一个数字时人们更习惯从高位写到低位，且高位是写在左边的。而这可以直接和内存的“图像”对应，而小端则需要把每个字的字节地址颠倒一下才可以。
例如，一个32位的整数0xffeeddcc，在内存里的存储情况如下。*（非对齐，起始地址为0x01）*

**大端**:
           0  1  2  3
0x00    00ffeedd
0x01    cc556677
**小端**:
           3  2  1  0
0x00    eeddcc00
0x01    776655ff
*ps.假设除去该整数存储的空间，字节地址与存储的十六进制数对应，即地址为0x01存11，0x05存55，这点用来突出字节地址是多少。*

## 2非对齐指令

instruction
lwl/swl, lwr/swr
usage
lwl t0, offset(s0)

*其中的left，与shift left的“左”都表示数据的高位。right则表示数据的低位。*

lwl表示将内存对应地址所在的字（align_address，即抹掉地址低两位对应地址）的数据低位复制到寄存器数据的高位。寄存器其它部分不变。

swl则表示将寄存器的数据高位复制到内存对应数据低位。其它部分不变。
即
lwl/swl
寄存器数据高位↹内存数据低位
lwr/swr
寄存器数据低位↹内存数据高位

### 1 从#1中读取该整数实例
大端
lwl s0, 0(1)
lwr s0, 3(1)
小端
lwr s0, 0(1)
lwl s0, 3(1)

*将整数以图中所示存储到内存中只需将lw\*改为sw\*。*

可以以此定义非对齐加载、存储伪指令，
如uld(rd, rb)表示非对齐load，加载内存[rb+3:rb]的数据，
uld(rd, rb)=>
lwl rd, 0(rb)
lwr rd, 3(rb)
*（可能uld是加载8字节，待确认）*

### 2 关于load/store多少字节
n为地址低2位，n=addr[1:0]
大端
lwl/swl  4-n
lwr/swr   n+1
小端
lwr/swr 4-n
lwl/swl n+1